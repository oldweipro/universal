// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: api/ai/v1/knowledge.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Knowledge_CreateKnowledgeBase_FullMethodName   = "/api.ai.v1.Knowledge/CreateKnowledgeBase"
	Knowledge_UpdateKnowledgeBase_FullMethodName   = "/api.ai.v1.Knowledge/UpdateKnowledgeBase"
	Knowledge_DeleteKnowledgeBase_FullMethodName   = "/api.ai.v1.Knowledge/DeleteKnowledgeBase"
	Knowledge_ListKnowledgeBases_FullMethodName    = "/api.ai.v1.Knowledge/ListKnowledgeBases"
	Knowledge_GetKnowledgeBase_FullMethodName      = "/api.ai.v1.Knowledge/GetKnowledgeBase"
	Knowledge_UploadDocument_FullMethodName        = "/api.ai.v1.Knowledge/UploadDocument"
	Knowledge_BatchUploadDocuments_FullMethodName  = "/api.ai.v1.Knowledge/BatchUploadDocuments"
	Knowledge_UpdateDocument_FullMethodName        = "/api.ai.v1.Knowledge/UpdateDocument"
	Knowledge_DeleteDocument_FullMethodName        = "/api.ai.v1.Knowledge/DeleteDocument"
	Knowledge_ListDocuments_FullMethodName         = "/api.ai.v1.Knowledge/ListDocuments"
	Knowledge_GetDocument_FullMethodName           = "/api.ai.v1.Knowledge/GetDocument"
	Knowledge_ProcessDocument_FullMethodName       = "/api.ai.v1.Knowledge/ProcessDocument"
	Knowledge_SearchKnowledge_FullMethodName       = "/api.ai.v1.Knowledge/SearchKnowledge"
	Knowledge_HybridSearch_FullMethodName          = "/api.ai.v1.Knowledge/HybridSearch"
	Knowledge_AdvancedSearch_FullMethodName        = "/api.ai.v1.Knowledge/AdvancedSearch"
	Knowledge_GetKnowledgeChunk_FullMethodName     = "/api.ai.v1.Knowledge/GetKnowledgeChunk"
	Knowledge_UpdateKnowledgeChunk_FullMethodName  = "/api.ai.v1.Knowledge/UpdateKnowledgeChunk"
	Knowledge_ListKnowledgeChunks_FullMethodName   = "/api.ai.v1.Knowledge/ListKnowledgeChunks"
	Knowledge_ReindexKnowledgeBase_FullMethodName  = "/api.ai.v1.Knowledge/ReindexKnowledgeBase"
	Knowledge_GetKnowledgeBaseStats_FullMethodName = "/api.ai.v1.Knowledge/GetKnowledgeBaseStats"
	Knowledge_AnalyzeKnowledgeBase_FullMethodName  = "/api.ai.v1.Knowledge/AnalyzeKnowledgeBase"
)

// KnowledgeClient is the client API for Knowledge service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 知识库管理服务
type KnowledgeClient interface {
	// CreateKnowledgeBase 创建新的知识库
	// 为用户创建知识库，可以指定向量化模型和分块策略
	CreateKnowledgeBase(ctx context.Context, in *CreateKnowledgeBaseRequest, opts ...grpc.CallOption) (*CreateKnowledgeBaseReply, error)
	// UpdateKnowledgeBase 更新知识库配置
	// 修改知识库的名称、描述、向量化模型等配置
	UpdateKnowledgeBase(ctx context.Context, in *UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) (*UpdateKnowledgeBaseReply, error)
	// DeleteKnowledgeBase 删除知识库
	// 软删除知识库及其所有文档和向量数据
	DeleteKnowledgeBase(ctx context.Context, in *DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) (*DeleteKnowledgeBaseReply, error)
	// ListKnowledgeBases 获取用户的知识库列表
	// 支持分页查询和关键词搜索
	ListKnowledgeBases(ctx context.Context, in *ListKnowledgeBasesRequest, opts ...grpc.CallOption) (*ListKnowledgeBasesReply, error)
	// GetKnowledgeBase 获取知识库详细信息
	// 根据ID获取知识库的完整信息和统计数据
	GetKnowledgeBase(ctx context.Context, in *GetKnowledgeBaseRequest, opts ...grpc.CallOption) (*GetKnowledgeBaseReply, error)
	// UploadDocument 向知识库上传文档
	// 上传文档到指定知识库，自动进行向量化处理
	UploadDocument(ctx context.Context, in *UploadDocumentRequest, opts ...grpc.CallOption) (*UploadDocumentReply, error)
	// BatchUploadDocuments 批量上传文档
	// 批量上传多个文档，支持进度跟踪
	BatchUploadDocuments(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BatchUploadDocumentsRequest, BatchUploadDocumentsReply], error)
	// UpdateDocument 更新文档内容
	// 更新已有文档的内容和元数据
	UpdateDocument(ctx context.Context, in *UpdateDocumentRequest, opts ...grpc.CallOption) (*UpdateDocumentReply, error)
	// DeleteDocument 删除文档
	// 从知识库中删除指定文档及其向量数据
	DeleteDocument(ctx context.Context, in *DeleteDocumentRequest, opts ...grpc.CallOption) (*DeleteDocumentReply, error)
	// ListDocuments 获取知识库中的文档列表
	// 支持分页查询和状态过滤
	ListDocuments(ctx context.Context, in *ListDocumentsRequest, opts ...grpc.CallOption) (*ListDocumentsReply, error)
	// GetDocument 获取文档详细信息
	// 根据ID获取文档的完整信息
	GetDocument(ctx context.Context, in *GetDocumentRequest, opts ...grpc.CallOption) (*GetDocumentReply, error)
	// ProcessDocument 处理文档
	// 手动触发文档的向量化处理
	ProcessDocument(ctx context.Context, in *ProcessDocumentRequest, opts ...grpc.CallOption) (*ProcessDocumentReply, error)
	// SearchKnowledge 在知识库中搜索相关内容
	// 基于语义相似度搜索知识库内容，支持相似度阈值过滤
	SearchKnowledge(ctx context.Context, in *SearchKnowledgeRequest, opts ...grpc.CallOption) (*SearchKnowledgeReply, error)
	// HybridSearch 混合搜索
	// 结合语义搜索和关键词搜索，提供更精确的结果
	HybridSearch(ctx context.Context, in *HybridSearchRequest, opts ...grpc.CallOption) (*HybridSearchReply, error)
	// AdvancedSearch 高级搜索
	// 支持多种搜索条件和过滤器的高级搜索
	AdvancedSearch(ctx context.Context, in *AdvancedSearchRequest, opts ...grpc.CallOption) (*AdvancedSearchReply, error)
	// GetKnowledgeChunk 获取知识块详细信息
	// 根据块ID获取知识块的完整信息
	GetKnowledgeChunk(ctx context.Context, in *GetKnowledgeChunkRequest, opts ...grpc.CallOption) (*GetKnowledgeChunkReply, error)
	// UpdateKnowledgeChunk 更新知识块
	// 更新知识块的内容和元数据
	UpdateKnowledgeChunk(ctx context.Context, in *UpdateKnowledgeChunkRequest, opts ...grpc.CallOption) (*UpdateKnowledgeChunkReply, error)
	// ListKnowledgeChunks 获取文档的知识块列表
	// 获取指定文档的所有知识块
	ListKnowledgeChunks(ctx context.Context, in *ListKnowledgeChunksRequest, opts ...grpc.CallOption) (*ListKnowledgeChunksReply, error)
	// ReindexKnowledgeBase 重新索引知识库
	// 重新对知识库中的所有文档进行向量化处理
	ReindexKnowledgeBase(ctx context.Context, in *ReindexKnowledgeBaseRequest, opts ...grpc.CallOption) (*ReindexKnowledgeBaseReply, error)
	// GetKnowledgeBaseStats 获取知识库统计信息
	// 返回知识库的详细统计数据
	GetKnowledgeBaseStats(ctx context.Context, in *GetKnowledgeBaseStatsRequest, opts ...grpc.CallOption) (*GetKnowledgeBaseStatsReply, error)
	// AnalyzeKnowledgeBase 分析知识库内容
	// 分析知识库的内容分布、主题等
	AnalyzeKnowledgeBase(ctx context.Context, in *AnalyzeKnowledgeBaseRequest, opts ...grpc.CallOption) (*AnalyzeKnowledgeBaseReply, error)
}

type knowledgeClient struct {
	cc grpc.ClientConnInterface
}

func NewKnowledgeClient(cc grpc.ClientConnInterface) KnowledgeClient {
	return &knowledgeClient{cc}
}

func (c *knowledgeClient) CreateKnowledgeBase(ctx context.Context, in *CreateKnowledgeBaseRequest, opts ...grpc.CallOption) (*CreateKnowledgeBaseReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateKnowledgeBaseReply)
	err := c.cc.Invoke(ctx, Knowledge_CreateKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) UpdateKnowledgeBase(ctx context.Context, in *UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) (*UpdateKnowledgeBaseReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateKnowledgeBaseReply)
	err := c.cc.Invoke(ctx, Knowledge_UpdateKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) DeleteKnowledgeBase(ctx context.Context, in *DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) (*DeleteKnowledgeBaseReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteKnowledgeBaseReply)
	err := c.cc.Invoke(ctx, Knowledge_DeleteKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) ListKnowledgeBases(ctx context.Context, in *ListKnowledgeBasesRequest, opts ...grpc.CallOption) (*ListKnowledgeBasesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKnowledgeBasesReply)
	err := c.cc.Invoke(ctx, Knowledge_ListKnowledgeBases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) GetKnowledgeBase(ctx context.Context, in *GetKnowledgeBaseRequest, opts ...grpc.CallOption) (*GetKnowledgeBaseReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKnowledgeBaseReply)
	err := c.cc.Invoke(ctx, Knowledge_GetKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) UploadDocument(ctx context.Context, in *UploadDocumentRequest, opts ...grpc.CallOption) (*UploadDocumentReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadDocumentReply)
	err := c.cc.Invoke(ctx, Knowledge_UploadDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) BatchUploadDocuments(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BatchUploadDocumentsRequest, BatchUploadDocumentsReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Knowledge_ServiceDesc.Streams[0], Knowledge_BatchUploadDocuments_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BatchUploadDocumentsRequest, BatchUploadDocumentsReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Knowledge_BatchUploadDocumentsClient = grpc.BidiStreamingClient[BatchUploadDocumentsRequest, BatchUploadDocumentsReply]

func (c *knowledgeClient) UpdateDocument(ctx context.Context, in *UpdateDocumentRequest, opts ...grpc.CallOption) (*UpdateDocumentReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDocumentReply)
	err := c.cc.Invoke(ctx, Knowledge_UpdateDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) DeleteDocument(ctx context.Context, in *DeleteDocumentRequest, opts ...grpc.CallOption) (*DeleteDocumentReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDocumentReply)
	err := c.cc.Invoke(ctx, Knowledge_DeleteDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) ListDocuments(ctx context.Context, in *ListDocumentsRequest, opts ...grpc.CallOption) (*ListDocumentsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDocumentsReply)
	err := c.cc.Invoke(ctx, Knowledge_ListDocuments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) GetDocument(ctx context.Context, in *GetDocumentRequest, opts ...grpc.CallOption) (*GetDocumentReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDocumentReply)
	err := c.cc.Invoke(ctx, Knowledge_GetDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) ProcessDocument(ctx context.Context, in *ProcessDocumentRequest, opts ...grpc.CallOption) (*ProcessDocumentReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessDocumentReply)
	err := c.cc.Invoke(ctx, Knowledge_ProcessDocument_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) SearchKnowledge(ctx context.Context, in *SearchKnowledgeRequest, opts ...grpc.CallOption) (*SearchKnowledgeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchKnowledgeReply)
	err := c.cc.Invoke(ctx, Knowledge_SearchKnowledge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) HybridSearch(ctx context.Context, in *HybridSearchRequest, opts ...grpc.CallOption) (*HybridSearchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HybridSearchReply)
	err := c.cc.Invoke(ctx, Knowledge_HybridSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) AdvancedSearch(ctx context.Context, in *AdvancedSearchRequest, opts ...grpc.CallOption) (*AdvancedSearchReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdvancedSearchReply)
	err := c.cc.Invoke(ctx, Knowledge_AdvancedSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) GetKnowledgeChunk(ctx context.Context, in *GetKnowledgeChunkRequest, opts ...grpc.CallOption) (*GetKnowledgeChunkReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKnowledgeChunkReply)
	err := c.cc.Invoke(ctx, Knowledge_GetKnowledgeChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) UpdateKnowledgeChunk(ctx context.Context, in *UpdateKnowledgeChunkRequest, opts ...grpc.CallOption) (*UpdateKnowledgeChunkReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateKnowledgeChunkReply)
	err := c.cc.Invoke(ctx, Knowledge_UpdateKnowledgeChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) ListKnowledgeChunks(ctx context.Context, in *ListKnowledgeChunksRequest, opts ...grpc.CallOption) (*ListKnowledgeChunksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKnowledgeChunksReply)
	err := c.cc.Invoke(ctx, Knowledge_ListKnowledgeChunks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) ReindexKnowledgeBase(ctx context.Context, in *ReindexKnowledgeBaseRequest, opts ...grpc.CallOption) (*ReindexKnowledgeBaseReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReindexKnowledgeBaseReply)
	err := c.cc.Invoke(ctx, Knowledge_ReindexKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) GetKnowledgeBaseStats(ctx context.Context, in *GetKnowledgeBaseStatsRequest, opts ...grpc.CallOption) (*GetKnowledgeBaseStatsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKnowledgeBaseStatsReply)
	err := c.cc.Invoke(ctx, Knowledge_GetKnowledgeBaseStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *knowledgeClient) AnalyzeKnowledgeBase(ctx context.Context, in *AnalyzeKnowledgeBaseRequest, opts ...grpc.CallOption) (*AnalyzeKnowledgeBaseReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeKnowledgeBaseReply)
	err := c.cc.Invoke(ctx, Knowledge_AnalyzeKnowledgeBase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KnowledgeServer is the server API for Knowledge service.
// All implementations must embed UnimplementedKnowledgeServer
// for forward compatibility.
//
// 知识库管理服务
type KnowledgeServer interface {
	// CreateKnowledgeBase 创建新的知识库
	// 为用户创建知识库，可以指定向量化模型和分块策略
	CreateKnowledgeBase(context.Context, *CreateKnowledgeBaseRequest) (*CreateKnowledgeBaseReply, error)
	// UpdateKnowledgeBase 更新知识库配置
	// 修改知识库的名称、描述、向量化模型等配置
	UpdateKnowledgeBase(context.Context, *UpdateKnowledgeBaseRequest) (*UpdateKnowledgeBaseReply, error)
	// DeleteKnowledgeBase 删除知识库
	// 软删除知识库及其所有文档和向量数据
	DeleteKnowledgeBase(context.Context, *DeleteKnowledgeBaseRequest) (*DeleteKnowledgeBaseReply, error)
	// ListKnowledgeBases 获取用户的知识库列表
	// 支持分页查询和关键词搜索
	ListKnowledgeBases(context.Context, *ListKnowledgeBasesRequest) (*ListKnowledgeBasesReply, error)
	// GetKnowledgeBase 获取知识库详细信息
	// 根据ID获取知识库的完整信息和统计数据
	GetKnowledgeBase(context.Context, *GetKnowledgeBaseRequest) (*GetKnowledgeBaseReply, error)
	// UploadDocument 向知识库上传文档
	// 上传文档到指定知识库，自动进行向量化处理
	UploadDocument(context.Context, *UploadDocumentRequest) (*UploadDocumentReply, error)
	// BatchUploadDocuments 批量上传文档
	// 批量上传多个文档，支持进度跟踪
	BatchUploadDocuments(grpc.BidiStreamingServer[BatchUploadDocumentsRequest, BatchUploadDocumentsReply]) error
	// UpdateDocument 更新文档内容
	// 更新已有文档的内容和元数据
	UpdateDocument(context.Context, *UpdateDocumentRequest) (*UpdateDocumentReply, error)
	// DeleteDocument 删除文档
	// 从知识库中删除指定文档及其向量数据
	DeleteDocument(context.Context, *DeleteDocumentRequest) (*DeleteDocumentReply, error)
	// ListDocuments 获取知识库中的文档列表
	// 支持分页查询和状态过滤
	ListDocuments(context.Context, *ListDocumentsRequest) (*ListDocumentsReply, error)
	// GetDocument 获取文档详细信息
	// 根据ID获取文档的完整信息
	GetDocument(context.Context, *GetDocumentRequest) (*GetDocumentReply, error)
	// ProcessDocument 处理文档
	// 手动触发文档的向量化处理
	ProcessDocument(context.Context, *ProcessDocumentRequest) (*ProcessDocumentReply, error)
	// SearchKnowledge 在知识库中搜索相关内容
	// 基于语义相似度搜索知识库内容，支持相似度阈值过滤
	SearchKnowledge(context.Context, *SearchKnowledgeRequest) (*SearchKnowledgeReply, error)
	// HybridSearch 混合搜索
	// 结合语义搜索和关键词搜索，提供更精确的结果
	HybridSearch(context.Context, *HybridSearchRequest) (*HybridSearchReply, error)
	// AdvancedSearch 高级搜索
	// 支持多种搜索条件和过滤器的高级搜索
	AdvancedSearch(context.Context, *AdvancedSearchRequest) (*AdvancedSearchReply, error)
	// GetKnowledgeChunk 获取知识块详细信息
	// 根据块ID获取知识块的完整信息
	GetKnowledgeChunk(context.Context, *GetKnowledgeChunkRequest) (*GetKnowledgeChunkReply, error)
	// UpdateKnowledgeChunk 更新知识块
	// 更新知识块的内容和元数据
	UpdateKnowledgeChunk(context.Context, *UpdateKnowledgeChunkRequest) (*UpdateKnowledgeChunkReply, error)
	// ListKnowledgeChunks 获取文档的知识块列表
	// 获取指定文档的所有知识块
	ListKnowledgeChunks(context.Context, *ListKnowledgeChunksRequest) (*ListKnowledgeChunksReply, error)
	// ReindexKnowledgeBase 重新索引知识库
	// 重新对知识库中的所有文档进行向量化处理
	ReindexKnowledgeBase(context.Context, *ReindexKnowledgeBaseRequest) (*ReindexKnowledgeBaseReply, error)
	// GetKnowledgeBaseStats 获取知识库统计信息
	// 返回知识库的详细统计数据
	GetKnowledgeBaseStats(context.Context, *GetKnowledgeBaseStatsRequest) (*GetKnowledgeBaseStatsReply, error)
	// AnalyzeKnowledgeBase 分析知识库内容
	// 分析知识库的内容分布、主题等
	AnalyzeKnowledgeBase(context.Context, *AnalyzeKnowledgeBaseRequest) (*AnalyzeKnowledgeBaseReply, error)
	mustEmbedUnimplementedKnowledgeServer()
}

// UnimplementedKnowledgeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKnowledgeServer struct{}

func (UnimplementedKnowledgeServer) CreateKnowledgeBase(context.Context, *CreateKnowledgeBaseRequest) (*CreateKnowledgeBaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKnowledgeBase not implemented")
}
func (UnimplementedKnowledgeServer) UpdateKnowledgeBase(context.Context, *UpdateKnowledgeBaseRequest) (*UpdateKnowledgeBaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKnowledgeBase not implemented")
}
func (UnimplementedKnowledgeServer) DeleteKnowledgeBase(context.Context, *DeleteKnowledgeBaseRequest) (*DeleteKnowledgeBaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKnowledgeBase not implemented")
}
func (UnimplementedKnowledgeServer) ListKnowledgeBases(context.Context, *ListKnowledgeBasesRequest) (*ListKnowledgeBasesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKnowledgeBases not implemented")
}
func (UnimplementedKnowledgeServer) GetKnowledgeBase(context.Context, *GetKnowledgeBaseRequest) (*GetKnowledgeBaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKnowledgeBase not implemented")
}
func (UnimplementedKnowledgeServer) UploadDocument(context.Context, *UploadDocumentRequest) (*UploadDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadDocument not implemented")
}
func (UnimplementedKnowledgeServer) BatchUploadDocuments(grpc.BidiStreamingServer[BatchUploadDocumentsRequest, BatchUploadDocumentsReply]) error {
	return status.Errorf(codes.Unimplemented, "method BatchUploadDocuments not implemented")
}
func (UnimplementedKnowledgeServer) UpdateDocument(context.Context, *UpdateDocumentRequest) (*UpdateDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDocument not implemented")
}
func (UnimplementedKnowledgeServer) DeleteDocument(context.Context, *DeleteDocumentRequest) (*DeleteDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDocument not implemented")
}
func (UnimplementedKnowledgeServer) ListDocuments(context.Context, *ListDocumentsRequest) (*ListDocumentsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDocuments not implemented")
}
func (UnimplementedKnowledgeServer) GetDocument(context.Context, *GetDocumentRequest) (*GetDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDocument not implemented")
}
func (UnimplementedKnowledgeServer) ProcessDocument(context.Context, *ProcessDocumentRequest) (*ProcessDocumentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessDocument not implemented")
}
func (UnimplementedKnowledgeServer) SearchKnowledge(context.Context, *SearchKnowledgeRequest) (*SearchKnowledgeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchKnowledge not implemented")
}
func (UnimplementedKnowledgeServer) HybridSearch(context.Context, *HybridSearchRequest) (*HybridSearchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HybridSearch not implemented")
}
func (UnimplementedKnowledgeServer) AdvancedSearch(context.Context, *AdvancedSearchRequest) (*AdvancedSearchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdvancedSearch not implemented")
}
func (UnimplementedKnowledgeServer) GetKnowledgeChunk(context.Context, *GetKnowledgeChunkRequest) (*GetKnowledgeChunkReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKnowledgeChunk not implemented")
}
func (UnimplementedKnowledgeServer) UpdateKnowledgeChunk(context.Context, *UpdateKnowledgeChunkRequest) (*UpdateKnowledgeChunkReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKnowledgeChunk not implemented")
}
func (UnimplementedKnowledgeServer) ListKnowledgeChunks(context.Context, *ListKnowledgeChunksRequest) (*ListKnowledgeChunksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKnowledgeChunks not implemented")
}
func (UnimplementedKnowledgeServer) ReindexKnowledgeBase(context.Context, *ReindexKnowledgeBaseRequest) (*ReindexKnowledgeBaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReindexKnowledgeBase not implemented")
}
func (UnimplementedKnowledgeServer) GetKnowledgeBaseStats(context.Context, *GetKnowledgeBaseStatsRequest) (*GetKnowledgeBaseStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKnowledgeBaseStats not implemented")
}
func (UnimplementedKnowledgeServer) AnalyzeKnowledgeBase(context.Context, *AnalyzeKnowledgeBaseRequest) (*AnalyzeKnowledgeBaseReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeKnowledgeBase not implemented")
}
func (UnimplementedKnowledgeServer) mustEmbedUnimplementedKnowledgeServer() {}
func (UnimplementedKnowledgeServer) testEmbeddedByValue()                   {}

// UnsafeKnowledgeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KnowledgeServer will
// result in compilation errors.
type UnsafeKnowledgeServer interface {
	mustEmbedUnimplementedKnowledgeServer()
}

func RegisterKnowledgeServer(s grpc.ServiceRegistrar, srv KnowledgeServer) {
	// If the following call pancis, it indicates UnimplementedKnowledgeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Knowledge_ServiceDesc, srv)
}

func _Knowledge_CreateKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKnowledgeBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).CreateKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_CreateKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).CreateKnowledgeBase(ctx, req.(*CreateKnowledgeBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_UpdateKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKnowledgeBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).UpdateKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_UpdateKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).UpdateKnowledgeBase(ctx, req.(*UpdateKnowledgeBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_DeleteKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKnowledgeBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).DeleteKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_DeleteKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).DeleteKnowledgeBase(ctx, req.(*DeleteKnowledgeBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_ListKnowledgeBases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKnowledgeBasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).ListKnowledgeBases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_ListKnowledgeBases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).ListKnowledgeBases(ctx, req.(*ListKnowledgeBasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_GetKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKnowledgeBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).GetKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_GetKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).GetKnowledgeBase(ctx, req.(*GetKnowledgeBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_UploadDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).UploadDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_UploadDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).UploadDocument(ctx, req.(*UploadDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_BatchUploadDocuments_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KnowledgeServer).BatchUploadDocuments(&grpc.GenericServerStream[BatchUploadDocumentsRequest, BatchUploadDocumentsReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Knowledge_BatchUploadDocumentsServer = grpc.BidiStreamingServer[BatchUploadDocumentsRequest, BatchUploadDocumentsReply]

func _Knowledge_UpdateDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).UpdateDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_UpdateDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).UpdateDocument(ctx, req.(*UpdateDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_DeleteDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).DeleteDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_DeleteDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).DeleteDocument(ctx, req.(*DeleteDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_ListDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).ListDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_ListDocuments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).ListDocuments(ctx, req.(*ListDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_GetDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).GetDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_GetDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).GetDocument(ctx, req.(*GetDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_ProcessDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).ProcessDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_ProcessDocument_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).ProcessDocument(ctx, req.(*ProcessDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_SearchKnowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchKnowledgeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).SearchKnowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_SearchKnowledge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).SearchKnowledge(ctx, req.(*SearchKnowledgeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_HybridSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HybridSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).HybridSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_HybridSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).HybridSearch(ctx, req.(*HybridSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_AdvancedSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdvancedSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).AdvancedSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_AdvancedSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).AdvancedSearch(ctx, req.(*AdvancedSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_GetKnowledgeChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKnowledgeChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).GetKnowledgeChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_GetKnowledgeChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).GetKnowledgeChunk(ctx, req.(*GetKnowledgeChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_UpdateKnowledgeChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKnowledgeChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).UpdateKnowledgeChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_UpdateKnowledgeChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).UpdateKnowledgeChunk(ctx, req.(*UpdateKnowledgeChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_ListKnowledgeChunks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKnowledgeChunksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).ListKnowledgeChunks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_ListKnowledgeChunks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).ListKnowledgeChunks(ctx, req.(*ListKnowledgeChunksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_ReindexKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReindexKnowledgeBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).ReindexKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_ReindexKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).ReindexKnowledgeBase(ctx, req.(*ReindexKnowledgeBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_GetKnowledgeBaseStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKnowledgeBaseStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).GetKnowledgeBaseStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_GetKnowledgeBaseStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).GetKnowledgeBaseStats(ctx, req.(*GetKnowledgeBaseStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Knowledge_AnalyzeKnowledgeBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeKnowledgeBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KnowledgeServer).AnalyzeKnowledgeBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Knowledge_AnalyzeKnowledgeBase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KnowledgeServer).AnalyzeKnowledgeBase(ctx, req.(*AnalyzeKnowledgeBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Knowledge_ServiceDesc is the grpc.ServiceDesc for Knowledge service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Knowledge_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.ai.v1.Knowledge",
	HandlerType: (*KnowledgeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKnowledgeBase",
			Handler:    _Knowledge_CreateKnowledgeBase_Handler,
		},
		{
			MethodName: "UpdateKnowledgeBase",
			Handler:    _Knowledge_UpdateKnowledgeBase_Handler,
		},
		{
			MethodName: "DeleteKnowledgeBase",
			Handler:    _Knowledge_DeleteKnowledgeBase_Handler,
		},
		{
			MethodName: "ListKnowledgeBases",
			Handler:    _Knowledge_ListKnowledgeBases_Handler,
		},
		{
			MethodName: "GetKnowledgeBase",
			Handler:    _Knowledge_GetKnowledgeBase_Handler,
		},
		{
			MethodName: "UploadDocument",
			Handler:    _Knowledge_UploadDocument_Handler,
		},
		{
			MethodName: "UpdateDocument",
			Handler:    _Knowledge_UpdateDocument_Handler,
		},
		{
			MethodName: "DeleteDocument",
			Handler:    _Knowledge_DeleteDocument_Handler,
		},
		{
			MethodName: "ListDocuments",
			Handler:    _Knowledge_ListDocuments_Handler,
		},
		{
			MethodName: "GetDocument",
			Handler:    _Knowledge_GetDocument_Handler,
		},
		{
			MethodName: "ProcessDocument",
			Handler:    _Knowledge_ProcessDocument_Handler,
		},
		{
			MethodName: "SearchKnowledge",
			Handler:    _Knowledge_SearchKnowledge_Handler,
		},
		{
			MethodName: "HybridSearch",
			Handler:    _Knowledge_HybridSearch_Handler,
		},
		{
			MethodName: "AdvancedSearch",
			Handler:    _Knowledge_AdvancedSearch_Handler,
		},
		{
			MethodName: "GetKnowledgeChunk",
			Handler:    _Knowledge_GetKnowledgeChunk_Handler,
		},
		{
			MethodName: "UpdateKnowledgeChunk",
			Handler:    _Knowledge_UpdateKnowledgeChunk_Handler,
		},
		{
			MethodName: "ListKnowledgeChunks",
			Handler:    _Knowledge_ListKnowledgeChunks_Handler,
		},
		{
			MethodName: "ReindexKnowledgeBase",
			Handler:    _Knowledge_ReindexKnowledgeBase_Handler,
		},
		{
			MethodName: "GetKnowledgeBaseStats",
			Handler:    _Knowledge_GetKnowledgeBaseStats_Handler,
		},
		{
			MethodName: "AnalyzeKnowledgeBase",
			Handler:    _Knowledge_AnalyzeKnowledgeBase_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchUploadDocuments",
			Handler:       _Knowledge_BatchUploadDocuments_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/ai/v1/knowledge.proto",
}
