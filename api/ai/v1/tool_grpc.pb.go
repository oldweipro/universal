// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: api/ai/v1/tool.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Tool_ListTools_FullMethodName               = "/api.ai.v1.Tool/ListTools"
	Tool_GetTool_FullMethodName                 = "/api.ai.v1.Tool/GetTool"
	Tool_CallTool_FullMethodName                = "/api.ai.v1.Tool/CallTool"
	Tool_CallToolStream_FullMethodName          = "/api.ai.v1.Tool/CallToolStream"
	Tool_GetToolSchema_FullMethodName           = "/api.ai.v1.Tool/GetToolSchema"
	Tool_ValidateToolArguments_FullMethodName   = "/api.ai.v1.Tool/ValidateToolArguments"
	Tool_BatchCallTools_FullMethodName          = "/api.ai.v1.Tool/BatchCallTools"
	Tool_ListMcpServers_FullMethodName          = "/api.ai.v1.Tool/ListMcpServers"
	Tool_GetMcpServer_FullMethodName            = "/api.ai.v1.Tool/GetMcpServer"
	Tool_RegisterMcpServer_FullMethodName       = "/api.ai.v1.Tool/RegisterMcpServer"
	Tool_UpdateMcpServer_FullMethodName         = "/api.ai.v1.Tool/UpdateMcpServer"
	Tool_DeleteMcpServer_FullMethodName         = "/api.ai.v1.Tool/DeleteMcpServer"
	Tool_TestMcpServer_FullMethodName           = "/api.ai.v1.Tool/TestMcpServer"
	Tool_ListResources_FullMethodName           = "/api.ai.v1.Tool/ListResources"
	Tool_GetResource_FullMethodName             = "/api.ai.v1.Tool/GetResource"
	Tool_SearchResources_FullMethodName         = "/api.ai.v1.Tool/SearchResources"
	Tool_WatchResource_FullMethodName           = "/api.ai.v1.Tool/WatchResource"
	Tool_GetToolExecutionHistory_FullMethodName = "/api.ai.v1.Tool/GetToolExecutionHistory"
	Tool_GetToolExecutionStats_FullMethodName   = "/api.ai.v1.Tool/GetToolExecutionStats"
	Tool_EnableTool_FullMethodName              = "/api.ai.v1.Tool/EnableTool"
	Tool_DisableTool_FullMethodName             = "/api.ai.v1.Tool/DisableTool"
	Tool_ConfigureTool_FullMethodName           = "/api.ai.v1.Tool/ConfigureTool"
	Tool_GetToolConfig_FullMethodName           = "/api.ai.v1.Tool/GetToolConfig"
)

// ToolClient is the client API for Tool service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MCP工具和资源管理服务
type ToolClient interface {
	// ListTools 获取可用的MCP工具列表
	// 支持按MCP服务器过滤，可选择只显示启用的工具
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsReply, error)
	// GetTool 获取指定工具的详细信息
	// 根据工具名称获取工具的完整配置和元数据
	GetTool(ctx context.Context, in *GetToolRequest, opts ...grpc.CallOption) (*GetToolReply, error)
	// CallTool 调用指定的MCP工具
	// 执行工具调用并返回结果，支持传入对话上下文
	CallTool(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (*CallToolResponse, error)
	// CallToolStream 流式调用工具
	// 支持长时间运行的工具调用，实时返回执行进度
	CallToolStream(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CallToolStreamResponse], error)
	// GetToolSchema 获取工具的参数Schema
	// 返回工具的详细信息和参数定义，用于动态表单生成
	GetToolSchema(ctx context.Context, in *GetToolSchemaRequest, opts ...grpc.CallOption) (*GetToolSchemaReply, error)
	// ValidateToolArguments 验证工具参数
	// 在实际调用前验证参数是否符合工具的Schema定义
	ValidateToolArguments(ctx context.Context, in *ValidateToolArgumentsRequest, opts ...grpc.CallOption) (*ValidateToolArgumentsReply, error)
	// BatchCallTools 批量调用工具
	// 同时调用多个工具，支持并行执行和依赖关系管理
	BatchCallTools(ctx context.Context, in *BatchCallToolsRequest, opts ...grpc.CallOption) (*BatchCallToolsReply, error)
	// ListMcpServers 获取MCP服务器列表
	// 返回所有已注册的MCP服务器信息
	ListMcpServers(ctx context.Context, in *ListMcpServersRequest, opts ...grpc.CallOption) (*ListMcpServersReply, error)
	// GetMcpServer 获取MCP服务器详细信息
	// 根据服务器ID获取服务器的配置和状态信息
	GetMcpServer(ctx context.Context, in *GetMcpServerRequest, opts ...grpc.CallOption) (*GetMcpServerReply, error)
	// RegisterMcpServer 注册新的MCP服务器
	// 添加新的MCP服务器到系统中
	RegisterMcpServer(ctx context.Context, in *RegisterMcpServerRequest, opts ...grpc.CallOption) (*RegisterMcpServerReply, error)
	// UpdateMcpServer 更新MCP服务器配置
	// 修改已注册的MCP服务器的配置信息
	UpdateMcpServer(ctx context.Context, in *UpdateMcpServerRequest, opts ...grpc.CallOption) (*UpdateMcpServerReply, error)
	// DeleteMcpServer 删除MCP服务器
	// 从系统中移除MCP服务器及其所有工具和资源
	DeleteMcpServer(ctx context.Context, in *DeleteMcpServerRequest, opts ...grpc.CallOption) (*DeleteMcpServerReply, error)
	// TestMcpServer 测试MCP服务器连接
	// 验证MCP服务器的连接状态和可用性
	TestMcpServer(ctx context.Context, in *TestMcpServerRequest, opts ...grpc.CallOption) (*TestMcpServerReply, error)
	// ListResources 获取可用的MCP资源列表
	// 支持按MCP服务器和MIME类型过滤
	ListResources(ctx context.Context, in *ListResourcesRequest, opts ...grpc.CallOption) (*ListResourcesReply, error)
	// GetResource 获取指定资源的内容
	// 根据资源URI获取资源内容和元数据
	GetResource(ctx context.Context, in *GetResourceRequest, opts ...grpc.CallOption) (*GetResourceReply, error)
	// SearchResources 搜索资源
	// 基于关键词和元数据搜索可用资源
	SearchResources(ctx context.Context, in *SearchResourcesRequest, opts ...grpc.CallOption) (*SearchResourcesReply, error)
	// WatchResource 监视资源变化
	// 订阅资源变化通知，实时获取资源更新
	WatchResource(ctx context.Context, in *WatchResourceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchResourceReply], error)
	// GetToolExecutionHistory 获取工具执行历史
	// 查询指定工具的执行历史记录
	GetToolExecutionHistory(ctx context.Context, in *GetToolExecutionHistoryRequest, opts ...grpc.CallOption) (*GetToolExecutionHistoryReply, error)
	// GetToolExecutionStats 获取工具执行统计
	// 获取工具使用的统计信息和性能指标
	GetToolExecutionStats(ctx context.Context, in *GetToolExecutionStatsRequest, opts ...grpc.CallOption) (*GetToolExecutionStatsReply, error)
	// EnableTool 启用工具
	// 启用指定的工具，使其可被调用
	EnableTool(ctx context.Context, in *EnableToolRequest, opts ...grpc.CallOption) (*EnableToolReply, error)
	// DisableTool 禁用工具
	// 禁用指定的工具，阻止其被调用
	DisableTool(ctx context.Context, in *DisableToolRequest, opts ...grpc.CallOption) (*DisableToolReply, error)
	// ConfigureTool 配置工具
	// 设置工具的特定配置参数
	ConfigureTool(ctx context.Context, in *ConfigureToolRequest, opts ...grpc.CallOption) (*ConfigureToolReply, error)
	// GetToolConfig 获取工具配置
	// 获取工具的当前配置信息
	GetToolConfig(ctx context.Context, in *GetToolConfigRequest, opts ...grpc.CallOption) (*GetToolConfigReply, error)
}

type toolClient struct {
	cc grpc.ClientConnInterface
}

func NewToolClient(cc grpc.ClientConnInterface) ToolClient {
	return &toolClient{cc}
}

func (c *toolClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsReply)
	err := c.cc.Invoke(ctx, Tool_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) GetTool(ctx context.Context, in *GetToolRequest, opts ...grpc.CallOption) (*GetToolReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToolReply)
	err := c.cc.Invoke(ctx, Tool_GetTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) CallTool(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (*CallToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallToolResponse)
	err := c.cc.Invoke(ctx, Tool_CallTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) CallToolStream(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CallToolStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tool_ServiceDesc.Streams[0], Tool_CallToolStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CallToolRequest, CallToolStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tool_CallToolStreamClient = grpc.ServerStreamingClient[CallToolStreamResponse]

func (c *toolClient) GetToolSchema(ctx context.Context, in *GetToolSchemaRequest, opts ...grpc.CallOption) (*GetToolSchemaReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToolSchemaReply)
	err := c.cc.Invoke(ctx, Tool_GetToolSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) ValidateToolArguments(ctx context.Context, in *ValidateToolArgumentsRequest, opts ...grpc.CallOption) (*ValidateToolArgumentsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateToolArgumentsReply)
	err := c.cc.Invoke(ctx, Tool_ValidateToolArguments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) BatchCallTools(ctx context.Context, in *BatchCallToolsRequest, opts ...grpc.CallOption) (*BatchCallToolsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchCallToolsReply)
	err := c.cc.Invoke(ctx, Tool_BatchCallTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) ListMcpServers(ctx context.Context, in *ListMcpServersRequest, opts ...grpc.CallOption) (*ListMcpServersReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMcpServersReply)
	err := c.cc.Invoke(ctx, Tool_ListMcpServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) GetMcpServer(ctx context.Context, in *GetMcpServerRequest, opts ...grpc.CallOption) (*GetMcpServerReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMcpServerReply)
	err := c.cc.Invoke(ctx, Tool_GetMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) RegisterMcpServer(ctx context.Context, in *RegisterMcpServerRequest, opts ...grpc.CallOption) (*RegisterMcpServerReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterMcpServerReply)
	err := c.cc.Invoke(ctx, Tool_RegisterMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) UpdateMcpServer(ctx context.Context, in *UpdateMcpServerRequest, opts ...grpc.CallOption) (*UpdateMcpServerReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateMcpServerReply)
	err := c.cc.Invoke(ctx, Tool_UpdateMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) DeleteMcpServer(ctx context.Context, in *DeleteMcpServerRequest, opts ...grpc.CallOption) (*DeleteMcpServerReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMcpServerReply)
	err := c.cc.Invoke(ctx, Tool_DeleteMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) TestMcpServer(ctx context.Context, in *TestMcpServerRequest, opts ...grpc.CallOption) (*TestMcpServerReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestMcpServerReply)
	err := c.cc.Invoke(ctx, Tool_TestMcpServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) ListResources(ctx context.Context, in *ListResourcesRequest, opts ...grpc.CallOption) (*ListResourcesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResourcesReply)
	err := c.cc.Invoke(ctx, Tool_ListResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) GetResource(ctx context.Context, in *GetResourceRequest, opts ...grpc.CallOption) (*GetResourceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResourceReply)
	err := c.cc.Invoke(ctx, Tool_GetResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) SearchResources(ctx context.Context, in *SearchResourcesRequest, opts ...grpc.CallOption) (*SearchResourcesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResourcesReply)
	err := c.cc.Invoke(ctx, Tool_SearchResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) WatchResource(ctx context.Context, in *WatchResourceRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchResourceReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Tool_ServiceDesc.Streams[1], Tool_WatchResource_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchResourceRequest, WatchResourceReply]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tool_WatchResourceClient = grpc.ServerStreamingClient[WatchResourceReply]

func (c *toolClient) GetToolExecutionHistory(ctx context.Context, in *GetToolExecutionHistoryRequest, opts ...grpc.CallOption) (*GetToolExecutionHistoryReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToolExecutionHistoryReply)
	err := c.cc.Invoke(ctx, Tool_GetToolExecutionHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) GetToolExecutionStats(ctx context.Context, in *GetToolExecutionStatsRequest, opts ...grpc.CallOption) (*GetToolExecutionStatsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToolExecutionStatsReply)
	err := c.cc.Invoke(ctx, Tool_GetToolExecutionStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) EnableTool(ctx context.Context, in *EnableToolRequest, opts ...grpc.CallOption) (*EnableToolReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableToolReply)
	err := c.cc.Invoke(ctx, Tool_EnableTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) DisableTool(ctx context.Context, in *DisableToolRequest, opts ...grpc.CallOption) (*DisableToolReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableToolReply)
	err := c.cc.Invoke(ctx, Tool_DisableTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) ConfigureTool(ctx context.Context, in *ConfigureToolRequest, opts ...grpc.CallOption) (*ConfigureToolReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigureToolReply)
	err := c.cc.Invoke(ctx, Tool_ConfigureTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *toolClient) GetToolConfig(ctx context.Context, in *GetToolConfigRequest, opts ...grpc.CallOption) (*GetToolConfigReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetToolConfigReply)
	err := c.cc.Invoke(ctx, Tool_GetToolConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ToolServer is the server API for Tool service.
// All implementations must embed UnimplementedToolServer
// for forward compatibility.
//
// MCP工具和资源管理服务
type ToolServer interface {
	// ListTools 获取可用的MCP工具列表
	// 支持按MCP服务器过滤，可选择只显示启用的工具
	ListTools(context.Context, *ListToolsRequest) (*ListToolsReply, error)
	// GetTool 获取指定工具的详细信息
	// 根据工具名称获取工具的完整配置和元数据
	GetTool(context.Context, *GetToolRequest) (*GetToolReply, error)
	// CallTool 调用指定的MCP工具
	// 执行工具调用并返回结果，支持传入对话上下文
	CallTool(context.Context, *CallToolRequest) (*CallToolResponse, error)
	// CallToolStream 流式调用工具
	// 支持长时间运行的工具调用，实时返回执行进度
	CallToolStream(*CallToolRequest, grpc.ServerStreamingServer[CallToolStreamResponse]) error
	// GetToolSchema 获取工具的参数Schema
	// 返回工具的详细信息和参数定义，用于动态表单生成
	GetToolSchema(context.Context, *GetToolSchemaRequest) (*GetToolSchemaReply, error)
	// ValidateToolArguments 验证工具参数
	// 在实际调用前验证参数是否符合工具的Schema定义
	ValidateToolArguments(context.Context, *ValidateToolArgumentsRequest) (*ValidateToolArgumentsReply, error)
	// BatchCallTools 批量调用工具
	// 同时调用多个工具，支持并行执行和依赖关系管理
	BatchCallTools(context.Context, *BatchCallToolsRequest) (*BatchCallToolsReply, error)
	// ListMcpServers 获取MCP服务器列表
	// 返回所有已注册的MCP服务器信息
	ListMcpServers(context.Context, *ListMcpServersRequest) (*ListMcpServersReply, error)
	// GetMcpServer 获取MCP服务器详细信息
	// 根据服务器ID获取服务器的配置和状态信息
	GetMcpServer(context.Context, *GetMcpServerRequest) (*GetMcpServerReply, error)
	// RegisterMcpServer 注册新的MCP服务器
	// 添加新的MCP服务器到系统中
	RegisterMcpServer(context.Context, *RegisterMcpServerRequest) (*RegisterMcpServerReply, error)
	// UpdateMcpServer 更新MCP服务器配置
	// 修改已注册的MCP服务器的配置信息
	UpdateMcpServer(context.Context, *UpdateMcpServerRequest) (*UpdateMcpServerReply, error)
	// DeleteMcpServer 删除MCP服务器
	// 从系统中移除MCP服务器及其所有工具和资源
	DeleteMcpServer(context.Context, *DeleteMcpServerRequest) (*DeleteMcpServerReply, error)
	// TestMcpServer 测试MCP服务器连接
	// 验证MCP服务器的连接状态和可用性
	TestMcpServer(context.Context, *TestMcpServerRequest) (*TestMcpServerReply, error)
	// ListResources 获取可用的MCP资源列表
	// 支持按MCP服务器和MIME类型过滤
	ListResources(context.Context, *ListResourcesRequest) (*ListResourcesReply, error)
	// GetResource 获取指定资源的内容
	// 根据资源URI获取资源内容和元数据
	GetResource(context.Context, *GetResourceRequest) (*GetResourceReply, error)
	// SearchResources 搜索资源
	// 基于关键词和元数据搜索可用资源
	SearchResources(context.Context, *SearchResourcesRequest) (*SearchResourcesReply, error)
	// WatchResource 监视资源变化
	// 订阅资源变化通知，实时获取资源更新
	WatchResource(*WatchResourceRequest, grpc.ServerStreamingServer[WatchResourceReply]) error
	// GetToolExecutionHistory 获取工具执行历史
	// 查询指定工具的执行历史记录
	GetToolExecutionHistory(context.Context, *GetToolExecutionHistoryRequest) (*GetToolExecutionHistoryReply, error)
	// GetToolExecutionStats 获取工具执行统计
	// 获取工具使用的统计信息和性能指标
	GetToolExecutionStats(context.Context, *GetToolExecutionStatsRequest) (*GetToolExecutionStatsReply, error)
	// EnableTool 启用工具
	// 启用指定的工具，使其可被调用
	EnableTool(context.Context, *EnableToolRequest) (*EnableToolReply, error)
	// DisableTool 禁用工具
	// 禁用指定的工具，阻止其被调用
	DisableTool(context.Context, *DisableToolRequest) (*DisableToolReply, error)
	// ConfigureTool 配置工具
	// 设置工具的特定配置参数
	ConfigureTool(context.Context, *ConfigureToolRequest) (*ConfigureToolReply, error)
	// GetToolConfig 获取工具配置
	// 获取工具的当前配置信息
	GetToolConfig(context.Context, *GetToolConfigRequest) (*GetToolConfigReply, error)
	mustEmbedUnimplementedToolServer()
}

// UnimplementedToolServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedToolServer struct{}

func (UnimplementedToolServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedToolServer) GetTool(context.Context, *GetToolRequest) (*GetToolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTool not implemented")
}
func (UnimplementedToolServer) CallTool(context.Context, *CallToolRequest) (*CallToolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTool not implemented")
}
func (UnimplementedToolServer) CallToolStream(*CallToolRequest, grpc.ServerStreamingServer[CallToolStreamResponse]) error {
	return status.Errorf(codes.Unimplemented, "method CallToolStream not implemented")
}
func (UnimplementedToolServer) GetToolSchema(context.Context, *GetToolSchemaRequest) (*GetToolSchemaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToolSchema not implemented")
}
func (UnimplementedToolServer) ValidateToolArguments(context.Context, *ValidateToolArgumentsRequest) (*ValidateToolArgumentsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToolArguments not implemented")
}
func (UnimplementedToolServer) BatchCallTools(context.Context, *BatchCallToolsRequest) (*BatchCallToolsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCallTools not implemented")
}
func (UnimplementedToolServer) ListMcpServers(context.Context, *ListMcpServersRequest) (*ListMcpServersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMcpServers not implemented")
}
func (UnimplementedToolServer) GetMcpServer(context.Context, *GetMcpServerRequest) (*GetMcpServerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMcpServer not implemented")
}
func (UnimplementedToolServer) RegisterMcpServer(context.Context, *RegisterMcpServerRequest) (*RegisterMcpServerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterMcpServer not implemented")
}
func (UnimplementedToolServer) UpdateMcpServer(context.Context, *UpdateMcpServerRequest) (*UpdateMcpServerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMcpServer not implemented")
}
func (UnimplementedToolServer) DeleteMcpServer(context.Context, *DeleteMcpServerRequest) (*DeleteMcpServerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMcpServer not implemented")
}
func (UnimplementedToolServer) TestMcpServer(context.Context, *TestMcpServerRequest) (*TestMcpServerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestMcpServer not implemented")
}
func (UnimplementedToolServer) ListResources(context.Context, *ListResourcesRequest) (*ListResourcesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListResources not implemented")
}
func (UnimplementedToolServer) GetResource(context.Context, *GetResourceRequest) (*GetResourceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResource not implemented")
}
func (UnimplementedToolServer) SearchResources(context.Context, *SearchResourcesRequest) (*SearchResourcesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchResources not implemented")
}
func (UnimplementedToolServer) WatchResource(*WatchResourceRequest, grpc.ServerStreamingServer[WatchResourceReply]) error {
	return status.Errorf(codes.Unimplemented, "method WatchResource not implemented")
}
func (UnimplementedToolServer) GetToolExecutionHistory(context.Context, *GetToolExecutionHistoryRequest) (*GetToolExecutionHistoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToolExecutionHistory not implemented")
}
func (UnimplementedToolServer) GetToolExecutionStats(context.Context, *GetToolExecutionStatsRequest) (*GetToolExecutionStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToolExecutionStats not implemented")
}
func (UnimplementedToolServer) EnableTool(context.Context, *EnableToolRequest) (*EnableToolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTool not implemented")
}
func (UnimplementedToolServer) DisableTool(context.Context, *DisableToolRequest) (*DisableToolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableTool not implemented")
}
func (UnimplementedToolServer) ConfigureTool(context.Context, *ConfigureToolRequest) (*ConfigureToolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureTool not implemented")
}
func (UnimplementedToolServer) GetToolConfig(context.Context, *GetToolConfigRequest) (*GetToolConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToolConfig not implemented")
}
func (UnimplementedToolServer) mustEmbedUnimplementedToolServer() {}
func (UnimplementedToolServer) testEmbeddedByValue()              {}

// UnsafeToolServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ToolServer will
// result in compilation errors.
type UnsafeToolServer interface {
	mustEmbedUnimplementedToolServer()
}

func RegisterToolServer(s grpc.ServiceRegistrar, srv ToolServer) {
	// If the following call pancis, it indicates UnimplementedToolServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Tool_ServiceDesc, srv)
}

func _Tool_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_GetTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetTool(ctx, req.(*GetToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_CallTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).CallTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_CallTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).CallTool(ctx, req.(*CallToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_CallToolStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CallToolRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ToolServer).CallToolStream(m, &grpc.GenericServerStream[CallToolRequest, CallToolStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tool_CallToolStreamServer = grpc.ServerStreamingServer[CallToolStreamResponse]

func _Tool_GetToolSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetToolSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetToolSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetToolSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetToolSchema(ctx, req.(*GetToolSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_ValidateToolArguments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateToolArgumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).ValidateToolArguments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_ValidateToolArguments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).ValidateToolArguments(ctx, req.(*ValidateToolArgumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_BatchCallTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCallToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).BatchCallTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_BatchCallTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).BatchCallTools(ctx, req.(*BatchCallToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_ListMcpServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMcpServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).ListMcpServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_ListMcpServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).ListMcpServers(ctx, req.(*ListMcpServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_GetMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetMcpServer(ctx, req.(*GetMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_RegisterMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).RegisterMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_RegisterMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).RegisterMcpServer(ctx, req.(*RegisterMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_UpdateMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).UpdateMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_UpdateMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).UpdateMcpServer(ctx, req.(*UpdateMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_DeleteMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).DeleteMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_DeleteMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).DeleteMcpServer(ctx, req.(*DeleteMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_TestMcpServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestMcpServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).TestMcpServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_TestMcpServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).TestMcpServer(ctx, req.(*TestMcpServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_ListResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).ListResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_ListResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).ListResources(ctx, req.(*ListResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_GetResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetResource(ctx, req.(*GetResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_SearchResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).SearchResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_SearchResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).SearchResources(ctx, req.(*SearchResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_WatchResource_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchResourceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ToolServer).WatchResource(m, &grpc.GenericServerStream[WatchResourceRequest, WatchResourceReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Tool_WatchResourceServer = grpc.ServerStreamingServer[WatchResourceReply]

func _Tool_GetToolExecutionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetToolExecutionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetToolExecutionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetToolExecutionHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetToolExecutionHistory(ctx, req.(*GetToolExecutionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_GetToolExecutionStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetToolExecutionStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetToolExecutionStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetToolExecutionStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetToolExecutionStats(ctx, req.(*GetToolExecutionStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_EnableTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).EnableTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_EnableTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).EnableTool(ctx, req.(*EnableToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_DisableTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).DisableTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_DisableTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).DisableTool(ctx, req.(*DisableToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_ConfigureTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).ConfigureTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_ConfigureTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).ConfigureTool(ctx, req.(*ConfigureToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tool_GetToolConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetToolConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolServer).GetToolConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Tool_GetToolConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolServer).GetToolConfig(ctx, req.(*GetToolConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Tool_ServiceDesc is the grpc.ServiceDesc for Tool service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tool_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.ai.v1.Tool",
	HandlerType: (*ToolServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTools",
			Handler:    _Tool_ListTools_Handler,
		},
		{
			MethodName: "GetTool",
			Handler:    _Tool_GetTool_Handler,
		},
		{
			MethodName: "CallTool",
			Handler:    _Tool_CallTool_Handler,
		},
		{
			MethodName: "GetToolSchema",
			Handler:    _Tool_GetToolSchema_Handler,
		},
		{
			MethodName: "ValidateToolArguments",
			Handler:    _Tool_ValidateToolArguments_Handler,
		},
		{
			MethodName: "BatchCallTools",
			Handler:    _Tool_BatchCallTools_Handler,
		},
		{
			MethodName: "ListMcpServers",
			Handler:    _Tool_ListMcpServers_Handler,
		},
		{
			MethodName: "GetMcpServer",
			Handler:    _Tool_GetMcpServer_Handler,
		},
		{
			MethodName: "RegisterMcpServer",
			Handler:    _Tool_RegisterMcpServer_Handler,
		},
		{
			MethodName: "UpdateMcpServer",
			Handler:    _Tool_UpdateMcpServer_Handler,
		},
		{
			MethodName: "DeleteMcpServer",
			Handler:    _Tool_DeleteMcpServer_Handler,
		},
		{
			MethodName: "TestMcpServer",
			Handler:    _Tool_TestMcpServer_Handler,
		},
		{
			MethodName: "ListResources",
			Handler:    _Tool_ListResources_Handler,
		},
		{
			MethodName: "GetResource",
			Handler:    _Tool_GetResource_Handler,
		},
		{
			MethodName: "SearchResources",
			Handler:    _Tool_SearchResources_Handler,
		},
		{
			MethodName: "GetToolExecutionHistory",
			Handler:    _Tool_GetToolExecutionHistory_Handler,
		},
		{
			MethodName: "GetToolExecutionStats",
			Handler:    _Tool_GetToolExecutionStats_Handler,
		},
		{
			MethodName: "EnableTool",
			Handler:    _Tool_EnableTool_Handler,
		},
		{
			MethodName: "DisableTool",
			Handler:    _Tool_DisableTool_Handler,
		},
		{
			MethodName: "ConfigureTool",
			Handler:    _Tool_ConfigureTool_Handler,
		},
		{
			MethodName: "GetToolConfig",
			Handler:    _Tool_GetToolConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CallToolStream",
			Handler:       _Tool_CallToolStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchResource",
			Handler:       _Tool_WatchResource_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/ai/v1/tool.proto",
}
