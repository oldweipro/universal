// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: api/ai/v1/model.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Model_CreateProvider_FullMethodName        = "/api.ai.v1.Model/CreateProvider"
	Model_UpdateProvider_FullMethodName        = "/api.ai.v1.Model/UpdateProvider"
	Model_DeleteProvider_FullMethodName        = "/api.ai.v1.Model/DeleteProvider"
	Model_ListProviders_FullMethodName         = "/api.ai.v1.Model/ListProviders"
	Model_TestProvider_FullMethodName          = "/api.ai.v1.Model/TestProvider"
	Model_CreateModel_FullMethodName           = "/api.ai.v1.Model/CreateModel"
	Model_UpdateModel_FullMethodName           = "/api.ai.v1.Model/UpdateModel"
	Model_DeleteModel_FullMethodName           = "/api.ai.v1.Model/DeleteModel"
	Model_ListModels_FullMethodName            = "/api.ai.v1.Model/ListModels"
	Model_GetModel_FullMethodName              = "/api.ai.v1.Model/GetModel"
	Model_SwitchModel_FullMethodName           = "/api.ai.v1.Model/SwitchModel"
	Model_GetUserQuota_FullMethodName          = "/api.ai.v1.Model/GetUserQuota"
	Model_UpdateUserQuota_FullMethodName       = "/api.ai.v1.Model/UpdateUserQuota"
	Model_GetUsageStats_FullMethodName         = "/api.ai.v1.Model/GetUsageStats"
	Model_ResetUsage_FullMethodName            = "/api.ai.v1.Model/ResetUsage"
	Model_CheckRateLimit_FullMethodName        = "/api.ai.v1.Model/CheckRateLimit"
	Model_GetRateLimitConfig_FullMethodName    = "/api.ai.v1.Model/GetRateLimitConfig"
	Model_UpdateRateLimitConfig_FullMethodName = "/api.ai.v1.Model/UpdateRateLimitConfig"
	Model_HealthCheck_FullMethodName           = "/api.ai.v1.Model/HealthCheck"
	Model_GetModelMetrics_FullMethodName       = "/api.ai.v1.Model/GetModelMetrics"
)

// ModelClient is the client API for Model service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AI模型管理服务接口定义
type ModelClient interface {
	// CreateProvider 注册新的AI模型提供商
	// 支持OpenAI、Claude、本地模型等不同类型的提供商
	CreateProvider(ctx context.Context, in *CreateProviderRequest, opts ...grpc.CallOption) (*CreateProviderReply, error)
	// UpdateProvider 更新模型提供商配置
	// 可以修改API密钥、基础URL、状态等配置信息
	UpdateProvider(ctx context.Context, in *UpdateProviderRequest, opts ...grpc.CallOption) (*UpdateProviderReply, error)
	// DeleteProvider 删除模型提供商
	// 软删除，同时会禁用该提供商下的所有模型
	DeleteProvider(ctx context.Context, in *DeleteProviderRequest, opts ...grpc.CallOption) (*DeleteProviderReply, error)
	// ListProviders 获取所有模型提供商列表
	// 支持按状态过滤，可选择只显示启用的提供商
	ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersReply, error)
	// TestProvider 测试模型提供商连接
	// 验证API密钥和网络连接是否正常
	TestProvider(ctx context.Context, in *TestProviderRequest, opts ...grpc.CallOption) (*TestProviderReply, error)
	// CreateModel 注册新的AI模型
	// 在指定提供商下创建模型配置
	CreateModel(ctx context.Context, in *CreateModelRequest, opts ...grpc.CallOption) (*CreateModelReply, error)
	// UpdateModel 更新模型配置
	// 修改模型参数、状态、限制等配置
	UpdateModel(ctx context.Context, in *UpdateModelRequest, opts ...grpc.CallOption) (*UpdateModelReply, error)
	// DeleteModel 删除模型
	// 软删除，禁用模型但保留配置
	DeleteModel(ctx context.Context, in *DeleteModelRequest, opts ...grpc.CallOption) (*DeleteModelReply, error)
	// ListModels 获取可用的AI模型列表
	// 支持按提供商、状态过滤
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsReply, error)
	// GetModel 获取指定模型的详细信息
	// 返回模型的完整配置和状态信息
	GetModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*GetModelReply, error)
	// SwitchModel 为用户切换默认使用的模型
	// 设置用户在对话中默认使用的模型
	SwitchModel(ctx context.Context, in *SwitchModelRequest, opts ...grpc.CallOption) (*SwitchModelReply, error)
	// GetUserQuota 获取用户的使用配额
	// 返回用户在不同模型上的配额限制和已用量
	GetUserQuota(ctx context.Context, in *GetUserQuotaRequest, opts ...grpc.CallOption) (*GetUserQuotaReply, error)
	// UpdateUserQuota 更新用户配额
	// 管理员接口，用于调整用户的使用限制
	UpdateUserQuota(ctx context.Context, in *UpdateUserQuotaRequest, opts ...grpc.CallOption) (*UpdateUserQuotaReply, error)
	// GetUsageStats 获取使用统计信息
	// 支持按时间范围、模型、用户等维度统计
	GetUsageStats(ctx context.Context, in *GetUsageStatsRequest, opts ...grpc.CallOption) (*GetUsageStatsReply, error)
	// ResetUsage 重置用户使用量
	// 管理员接口，用于重置特定用户或全局使用量
	ResetUsage(ctx context.Context, in *ResetUsageRequest, opts ...grpc.CallOption) (*ResetUsageReply, error)
	// CheckRateLimit 检查请求是否超出速率限制
	// 在发送请求前检查用户是否还能继续请求
	CheckRateLimit(ctx context.Context, in *CheckRateLimitRequest, opts ...grpc.CallOption) (*CheckRateLimitReply, error)
	// GetRateLimitConfig 获取限流配置
	// 返回不同模型和用户等级的限流规则
	GetRateLimitConfig(ctx context.Context, in *GetRateLimitConfigRequest, opts ...grpc.CallOption) (*GetRateLimitConfigReply, error)
	// UpdateRateLimitConfig 更新限流配置
	// 管理员接口，用于调整限流规则
	UpdateRateLimitConfig(ctx context.Context, in *UpdateRateLimitConfigRequest, opts ...grpc.CallOption) (*UpdateRateLimitConfigReply, error)
	// HealthCheck 检查指定模型的健康状态
	// 测试模型服务的可用性和响应时间
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckReply, error)
	// GetModelMetrics 获取模型性能指标
	// 返回模型的响应时间、成功率等监控数据
	GetModelMetrics(ctx context.Context, in *GetModelMetricsRequest, opts ...grpc.CallOption) (*GetModelMetricsReply, error)
}

type modelClient struct {
	cc grpc.ClientConnInterface
}

func NewModelClient(cc grpc.ClientConnInterface) ModelClient {
	return &modelClient{cc}
}

func (c *modelClient) CreateProvider(ctx context.Context, in *CreateProviderRequest, opts ...grpc.CallOption) (*CreateProviderReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProviderReply)
	err := c.cc.Invoke(ctx, Model_CreateProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) UpdateProvider(ctx context.Context, in *UpdateProviderRequest, opts ...grpc.CallOption) (*UpdateProviderReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProviderReply)
	err := c.cc.Invoke(ctx, Model_UpdateProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) DeleteProvider(ctx context.Context, in *DeleteProviderRequest, opts ...grpc.CallOption) (*DeleteProviderReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProviderReply)
	err := c.cc.Invoke(ctx, Model_DeleteProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) ListProviders(ctx context.Context, in *ListProvidersRequest, opts ...grpc.CallOption) (*ListProvidersReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProvidersReply)
	err := c.cc.Invoke(ctx, Model_ListProviders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) TestProvider(ctx context.Context, in *TestProviderRequest, opts ...grpc.CallOption) (*TestProviderReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestProviderReply)
	err := c.cc.Invoke(ctx, Model_TestProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) CreateModel(ctx context.Context, in *CreateModelRequest, opts ...grpc.CallOption) (*CreateModelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateModelReply)
	err := c.cc.Invoke(ctx, Model_CreateModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) UpdateModel(ctx context.Context, in *UpdateModelRequest, opts ...grpc.CallOption) (*UpdateModelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateModelReply)
	err := c.cc.Invoke(ctx, Model_UpdateModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) DeleteModel(ctx context.Context, in *DeleteModelRequest, opts ...grpc.CallOption) (*DeleteModelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteModelReply)
	err := c.cc.Invoke(ctx, Model_DeleteModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelsReply)
	err := c.cc.Invoke(ctx, Model_ListModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) GetModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*GetModelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelReply)
	err := c.cc.Invoke(ctx, Model_GetModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) SwitchModel(ctx context.Context, in *SwitchModelRequest, opts ...grpc.CallOption) (*SwitchModelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwitchModelReply)
	err := c.cc.Invoke(ctx, Model_SwitchModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) GetUserQuota(ctx context.Context, in *GetUserQuotaRequest, opts ...grpc.CallOption) (*GetUserQuotaReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserQuotaReply)
	err := c.cc.Invoke(ctx, Model_GetUserQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) UpdateUserQuota(ctx context.Context, in *UpdateUserQuotaRequest, opts ...grpc.CallOption) (*UpdateUserQuotaReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserQuotaReply)
	err := c.cc.Invoke(ctx, Model_UpdateUserQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) GetUsageStats(ctx context.Context, in *GetUsageStatsRequest, opts ...grpc.CallOption) (*GetUsageStatsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsageStatsReply)
	err := c.cc.Invoke(ctx, Model_GetUsageStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) ResetUsage(ctx context.Context, in *ResetUsageRequest, opts ...grpc.CallOption) (*ResetUsageReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetUsageReply)
	err := c.cc.Invoke(ctx, Model_ResetUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) CheckRateLimit(ctx context.Context, in *CheckRateLimitRequest, opts ...grpc.CallOption) (*CheckRateLimitReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckRateLimitReply)
	err := c.cc.Invoke(ctx, Model_CheckRateLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) GetRateLimitConfig(ctx context.Context, in *GetRateLimitConfigRequest, opts ...grpc.CallOption) (*GetRateLimitConfigReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRateLimitConfigReply)
	err := c.cc.Invoke(ctx, Model_GetRateLimitConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) UpdateRateLimitConfig(ctx context.Context, in *UpdateRateLimitConfigRequest, opts ...grpc.CallOption) (*UpdateRateLimitConfigReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRateLimitConfigReply)
	err := c.cc.Invoke(ctx, Model_UpdateRateLimitConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckReply)
	err := c.cc.Invoke(ctx, Model_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) GetModelMetrics(ctx context.Context, in *GetModelMetricsRequest, opts ...grpc.CallOption) (*GetModelMetricsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelMetricsReply)
	err := c.cc.Invoke(ctx, Model_GetModelMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModelServer is the server API for Model service.
// All implementations must embed UnimplementedModelServer
// for forward compatibility.
//
// AI模型管理服务接口定义
type ModelServer interface {
	// CreateProvider 注册新的AI模型提供商
	// 支持OpenAI、Claude、本地模型等不同类型的提供商
	CreateProvider(context.Context, *CreateProviderRequest) (*CreateProviderReply, error)
	// UpdateProvider 更新模型提供商配置
	// 可以修改API密钥、基础URL、状态等配置信息
	UpdateProvider(context.Context, *UpdateProviderRequest) (*UpdateProviderReply, error)
	// DeleteProvider 删除模型提供商
	// 软删除，同时会禁用该提供商下的所有模型
	DeleteProvider(context.Context, *DeleteProviderRequest) (*DeleteProviderReply, error)
	// ListProviders 获取所有模型提供商列表
	// 支持按状态过滤，可选择只显示启用的提供商
	ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersReply, error)
	// TestProvider 测试模型提供商连接
	// 验证API密钥和网络连接是否正常
	TestProvider(context.Context, *TestProviderRequest) (*TestProviderReply, error)
	// CreateModel 注册新的AI模型
	// 在指定提供商下创建模型配置
	CreateModel(context.Context, *CreateModelRequest) (*CreateModelReply, error)
	// UpdateModel 更新模型配置
	// 修改模型参数、状态、限制等配置
	UpdateModel(context.Context, *UpdateModelRequest) (*UpdateModelReply, error)
	// DeleteModel 删除模型
	// 软删除，禁用模型但保留配置
	DeleteModel(context.Context, *DeleteModelRequest) (*DeleteModelReply, error)
	// ListModels 获取可用的AI模型列表
	// 支持按提供商、状态过滤
	ListModels(context.Context, *ListModelsRequest) (*ListModelsReply, error)
	// GetModel 获取指定模型的详细信息
	// 返回模型的完整配置和状态信息
	GetModel(context.Context, *GetModelRequest) (*GetModelReply, error)
	// SwitchModel 为用户切换默认使用的模型
	// 设置用户在对话中默认使用的模型
	SwitchModel(context.Context, *SwitchModelRequest) (*SwitchModelReply, error)
	// GetUserQuota 获取用户的使用配额
	// 返回用户在不同模型上的配额限制和已用量
	GetUserQuota(context.Context, *GetUserQuotaRequest) (*GetUserQuotaReply, error)
	// UpdateUserQuota 更新用户配额
	// 管理员接口，用于调整用户的使用限制
	UpdateUserQuota(context.Context, *UpdateUserQuotaRequest) (*UpdateUserQuotaReply, error)
	// GetUsageStats 获取使用统计信息
	// 支持按时间范围、模型、用户等维度统计
	GetUsageStats(context.Context, *GetUsageStatsRequest) (*GetUsageStatsReply, error)
	// ResetUsage 重置用户使用量
	// 管理员接口，用于重置特定用户或全局使用量
	ResetUsage(context.Context, *ResetUsageRequest) (*ResetUsageReply, error)
	// CheckRateLimit 检查请求是否超出速率限制
	// 在发送请求前检查用户是否还能继续请求
	CheckRateLimit(context.Context, *CheckRateLimitRequest) (*CheckRateLimitReply, error)
	// GetRateLimitConfig 获取限流配置
	// 返回不同模型和用户等级的限流规则
	GetRateLimitConfig(context.Context, *GetRateLimitConfigRequest) (*GetRateLimitConfigReply, error)
	// UpdateRateLimitConfig 更新限流配置
	// 管理员接口，用于调整限流规则
	UpdateRateLimitConfig(context.Context, *UpdateRateLimitConfigRequest) (*UpdateRateLimitConfigReply, error)
	// HealthCheck 检查指定模型的健康状态
	// 测试模型服务的可用性和响应时间
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckReply, error)
	// GetModelMetrics 获取模型性能指标
	// 返回模型的响应时间、成功率等监控数据
	GetModelMetrics(context.Context, *GetModelMetricsRequest) (*GetModelMetricsReply, error)
	mustEmbedUnimplementedModelServer()
}

// UnimplementedModelServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedModelServer struct{}

func (UnimplementedModelServer) CreateProvider(context.Context, *CreateProviderRequest) (*CreateProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProvider not implemented")
}
func (UnimplementedModelServer) UpdateProvider(context.Context, *UpdateProviderRequest) (*UpdateProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProvider not implemented")
}
func (UnimplementedModelServer) DeleteProvider(context.Context, *DeleteProviderRequest) (*DeleteProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProvider not implemented")
}
func (UnimplementedModelServer) ListProviders(context.Context, *ListProvidersRequest) (*ListProvidersReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProviders not implemented")
}
func (UnimplementedModelServer) TestProvider(context.Context, *TestProviderRequest) (*TestProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestProvider not implemented")
}
func (UnimplementedModelServer) CreateModel(context.Context, *CreateModelRequest) (*CreateModelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateModel not implemented")
}
func (UnimplementedModelServer) UpdateModel(context.Context, *UpdateModelRequest) (*UpdateModelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateModel not implemented")
}
func (UnimplementedModelServer) DeleteModel(context.Context, *DeleteModelRequest) (*DeleteModelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteModel not implemented")
}
func (UnimplementedModelServer) ListModels(context.Context, *ListModelsRequest) (*ListModelsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}
func (UnimplementedModelServer) GetModel(context.Context, *GetModelRequest) (*GetModelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModel not implemented")
}
func (UnimplementedModelServer) SwitchModel(context.Context, *SwitchModelRequest) (*SwitchModelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchModel not implemented")
}
func (UnimplementedModelServer) GetUserQuota(context.Context, *GetUserQuotaRequest) (*GetUserQuotaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserQuota not implemented")
}
func (UnimplementedModelServer) UpdateUserQuota(context.Context, *UpdateUserQuotaRequest) (*UpdateUserQuotaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserQuota not implemented")
}
func (UnimplementedModelServer) GetUsageStats(context.Context, *GetUsageStatsRequest) (*GetUsageStatsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsageStats not implemented")
}
func (UnimplementedModelServer) ResetUsage(context.Context, *ResetUsageRequest) (*ResetUsageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetUsage not implemented")
}
func (UnimplementedModelServer) CheckRateLimit(context.Context, *CheckRateLimitRequest) (*CheckRateLimitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckRateLimit not implemented")
}
func (UnimplementedModelServer) GetRateLimitConfig(context.Context, *GetRateLimitConfigRequest) (*GetRateLimitConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRateLimitConfig not implemented")
}
func (UnimplementedModelServer) UpdateRateLimitConfig(context.Context, *UpdateRateLimitConfigRequest) (*UpdateRateLimitConfigReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRateLimitConfig not implemented")
}
func (UnimplementedModelServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedModelServer) GetModelMetrics(context.Context, *GetModelMetricsRequest) (*GetModelMetricsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelMetrics not implemented")
}
func (UnimplementedModelServer) mustEmbedUnimplementedModelServer() {}
func (UnimplementedModelServer) testEmbeddedByValue()               {}

// UnsafeModelServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModelServer will
// result in compilation errors.
type UnsafeModelServer interface {
	mustEmbedUnimplementedModelServer()
}

func RegisterModelServer(s grpc.ServiceRegistrar, srv ModelServer) {
	// If the following call pancis, it indicates UnimplementedModelServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Model_ServiceDesc, srv)
}

func _Model_CreateProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).CreateProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_CreateProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).CreateProvider(ctx, req.(*CreateProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_UpdateProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).UpdateProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_UpdateProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).UpdateProvider(ctx, req.(*UpdateProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_DeleteProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).DeleteProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_DeleteProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).DeleteProvider(ctx, req.(*DeleteProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_ListProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).ListProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_ListProviders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).ListProviders(ctx, req.(*ListProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_TestProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).TestProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_TestProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).TestProvider(ctx, req.(*TestProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_CreateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).CreateModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_CreateModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).CreateModel(ctx, req.(*CreateModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_UpdateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).UpdateModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_UpdateModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).UpdateModel(ctx, req.(*UpdateModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_DeleteModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).DeleteModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_DeleteModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).DeleteModel(ctx, req.(*DeleteModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_ListModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_GetModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).GetModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_GetModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).GetModel(ctx, req.(*GetModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_SwitchModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).SwitchModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_SwitchModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).SwitchModel(ctx, req.(*SwitchModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_GetUserQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).GetUserQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_GetUserQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).GetUserQuota(ctx, req.(*GetUserQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_UpdateUserQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).UpdateUserQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_UpdateUserQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).UpdateUserQuota(ctx, req.(*UpdateUserQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_GetUsageStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsageStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).GetUsageStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_GetUsageStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).GetUsageStats(ctx, req.(*GetUsageStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_ResetUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).ResetUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_ResetUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).ResetUsage(ctx, req.(*ResetUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_CheckRateLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRateLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).CheckRateLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_CheckRateLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).CheckRateLimit(ctx, req.(*CheckRateLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_GetRateLimitConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRateLimitConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).GetRateLimitConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_GetRateLimitConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).GetRateLimitConfig(ctx, req.(*GetRateLimitConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_UpdateRateLimitConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRateLimitConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).UpdateRateLimitConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_UpdateRateLimitConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).UpdateRateLimitConfig(ctx, req.(*UpdateRateLimitConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_GetModelMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).GetModelMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_GetModelMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).GetModelMetrics(ctx, req.(*GetModelMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Model_ServiceDesc is the grpc.ServiceDesc for Model service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Model_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.ai.v1.Model",
	HandlerType: (*ModelServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProvider",
			Handler:    _Model_CreateProvider_Handler,
		},
		{
			MethodName: "UpdateProvider",
			Handler:    _Model_UpdateProvider_Handler,
		},
		{
			MethodName: "DeleteProvider",
			Handler:    _Model_DeleteProvider_Handler,
		},
		{
			MethodName: "ListProviders",
			Handler:    _Model_ListProviders_Handler,
		},
		{
			MethodName: "TestProvider",
			Handler:    _Model_TestProvider_Handler,
		},
		{
			MethodName: "CreateModel",
			Handler:    _Model_CreateModel_Handler,
		},
		{
			MethodName: "UpdateModel",
			Handler:    _Model_UpdateModel_Handler,
		},
		{
			MethodName: "DeleteModel",
			Handler:    _Model_DeleteModel_Handler,
		},
		{
			MethodName: "ListModels",
			Handler:    _Model_ListModels_Handler,
		},
		{
			MethodName: "GetModel",
			Handler:    _Model_GetModel_Handler,
		},
		{
			MethodName: "SwitchModel",
			Handler:    _Model_SwitchModel_Handler,
		},
		{
			MethodName: "GetUserQuota",
			Handler:    _Model_GetUserQuota_Handler,
		},
		{
			MethodName: "UpdateUserQuota",
			Handler:    _Model_UpdateUserQuota_Handler,
		},
		{
			MethodName: "GetUsageStats",
			Handler:    _Model_GetUsageStats_Handler,
		},
		{
			MethodName: "ResetUsage",
			Handler:    _Model_ResetUsage_Handler,
		},
		{
			MethodName: "CheckRateLimit",
			Handler:    _Model_CheckRateLimit_Handler,
		},
		{
			MethodName: "GetRateLimitConfig",
			Handler:    _Model_GetRateLimitConfig_Handler,
		},
		{
			MethodName: "UpdateRateLimitConfig",
			Handler:    _Model_UpdateRateLimitConfig_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _Model_HealthCheck_Handler,
		},
		{
			MethodName: "GetModelMetrics",
			Handler:    _Model_GetModelMetrics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/ai/v1/model.proto",
}
